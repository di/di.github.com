---
layout : transcript
category : talks
title : 'Static Typing in Python'
date : 2020-03-19 00:00:00 -0600
venues:
  - date: 2020-04-22 00:00:00 -0600
    venue: "PyCon US 2020"
    venue_url: "https://us.pycon.org/2020/schedule/presentation/96/"
    location: Pittsburgh, PA
    links:
      video: "https://www.youtube.com/watch?v=ST33zDM9vOE"

  - date: 2019-10-10 00:00:00 -0600
    venue: "PyCon DE 2019"
    venue_url: "https://de.pycon.org/program/pyconde-nh9uey-static-typing-in-python-dustin-ingram/"
    location: Berlin, DE
    links:
      video: "https://www.youtube.com/watch?v=p-nhGq-Wwv8"

  - date: 2019-10-04 00:00:00 -0600
    venue: "PyGotham 2019"
    venue_url: "https://2019.pygotham.org/talks/static-typing-in-python/"
    location: New York, NY
    links:
      video: "https://www.youtube.com/watch?v=2gBP1qN5T7I"

  - date: 2019-09-24 00:00:00 -0600
    venue: "DjangoCon US 2019"
    venue_url: "https://2019.djangocon.us/talks/static-typing-in-python/"
    location: San Diego, CA
    links:
      video: "https://www.youtube.com/watch?v=5pluSWgTa6I"

  - date: 2019-09-13 00:00:00 -0600
    venue: "PyCon UK 2019"
    venue_url: "https://pretalx.com/pyconuk-2019/schedule/"
    location: Cardiff, UK
    links:
      video: "https://www.youtube.com/watch?v=L8sWR5kRlxM"

  - date: 2019-09-08 00:00:00 -0600
    venue: "PyColorado 2019"
    venue_url: "https://pycolorado.org/schedule"
    location: Denver, CO
    links:
      video: "https://www.youtube.com/watch?v=8BNuawmpFXQ"
image : assets/images/static_typing/TV_noise.jpg
description : 'A discussion on type systems, the introduction of static typing to Python, and related tools.'
---

<div class="slides">
<table>

  <tr><td><a href="#6"><img id="6" class="slide" src="/assets/images/static_typing/6.png"></a></td><td>
    <p>
      I want to start with a pop quiz: is Python dynamically or statically typed?
    </p><p>
      Maybe you think it's dynamically typed.
      Maybe you think, hmm, this is a talk about 'Static Typing in Python', so it's probably statically typed?
    </p><p>
      Or maybe you think this is a trick question?
    </p>
  </td></tr>
  <tr><td><a href="#7"><img id="7" class="slide" src="/assets/images/static_typing/7.png"></a></td><td>
    <p>
      Yeah, it's a trick question.
    </p><p>
      The answer is that Python is dynamically typed, but it can optionally be as statically typed as you want it to be.
    </p><p>
      And if that doesn't make any sense to you, that's OK, you're in the right talk, and we'll break down everything that's necessary to understand that answer.
    </p>
  </td></tr>
  <tr><td><a href="#8"><img id="8" class="slide" src="/assets/images/static_typing/8.png"></a></td><td>
    <p>
      To understand that, we need to understand types in Python, and type systems in general.
    </p><p>
      We'll talk about dynamic typing in Python, then we'll talk about static typing in Python.
    </p>
  </td></tr>
  <tr><td><a href="#9"><img id="9" class="slide" src="/assets/images/static_typing/9.png"></a></td><td>
    <p>
      Once we understand that, we'll talk about how to use static typing in Python, when you should use it, and when you maybe shouldn't use it as well.
    </p>
  </td></tr>
  <tr><td><a href="#10"><img id="10" class="slide" src="/assets/images/static_typing/10.png"></a></td><td>
    <p>
     Let's talk about types, and specifically let's talk about <code>type</code>, the builtin keyword in Python.
    </p>
  </td></tr>
  <tr><td><a href="#11"><img id="11" class="slide" src="/assets/images/static_typing/11.png"></a></td><td>
    <p>
      In Python, in our REPL, we can type something like this: <code>type(42)</code>, and we get back something that says it's of the class <code>int</code>.
      Since forty-two is an integer, this makes sense.
    </p>
  </td></tr>
  <tr><td><a href="#12"><img id="12" class="slide" src="/assets/images/static_typing/12.png"></a></td><td>
    <p>
      We can do the same thing for floats...
    </p>
  </td></tr>
  <tr><td><a href="#13"><img id="13" class="slide" src="/assets/images/static_typing/13.png"></a></td><td>
    <p>
      ...strings...
    </p>
  </td></tr>
  <tr><td><a href="#14"><img id="14" class="slide" src="/assets/images/static_typing/14.png"></a></td><td>
    <p>
      ...lists, etc.
    </p><p>
      The <code>type</code> builtin tells us what type a given object is.
    </p><p>
      You might say, "oh, I recognize these things, <code>str</code>, <code>int</code>, <code>float</code>, this is what I use to change one type into another."
    </p>
  </td></tr>
  <tr><td><a href="#15"><img id="15" class="slide" src="/assets/images/static_typing/15.png"></a></td><td>
    <p>
      And yeah, you could have a variable like this, <code>a = 42</code>...
    </p>
  </td></tr>
  <tr><td><a href="#16"><img id="16" class="slide" src="/assets/images/static_typing/16.png"></a></td><td>
    <p>
      ...you call <code>float()</code> on it and you get a float...
    </p>
  </td></tr>
  <tr><td><a href="#17"><img id="17" class="slide" src="/assets/images/static_typing/17.png"></a></td><td>
    <p>
      ...you call <code>str()</code> on it and you get a string...
    </p>
  </td></tr>
  <tr><td><a href="#18"><img id="18" class="slide" src="/assets/images/static_typing/18.png"></a></td><td>
    <p>
      ...and you can call <code>list()</code> on it and you get a really ugly list.
    </p><p>
      Who's seen a really ugly list like this before, where a string is getting turned into a list? That's a type error!
    </p><p>
      You've had a type error in your code, where something that was expecting an iterable, like a list, and got a string instead, and Python did this.
    </p>
  </td></tr>
  <tr><td><a href="#19"><img id="19" class="slide" src="/assets/images/static_typing/19.png"></a></td><td>
    <p>
      The thing to note here is that things like <code>int</code> look like all the types available to us, but they're just classes which correspond to builtins.
    </p><p>
      Here <code>int</code> is just a keyword that corresponds to a class.
      When you do <code>isinstance(42, int)</code>, it's just doing class matching, and is telling you whether it's a member of that class or not.
    </p>
  </td></tr>
  <tr><td><a href="#20"><img id="20" class="slide" src="/assets/images/static_typing/20.png"></a></td><td>
    <p>
      But there are other types as well, right? Perhaps you've gotten a <code>NoneType</code> error.
      <code>NoneType</code> is the type of <code>None</code>, but we don't see <code>NoneType</code> as a keyword in Python, we just see it in our stack traces.
    </p><p>
      Similarly there's a <code>function</code> type, but we don't use the keyword <code>function</code> to define a function in Python, we say <code>def: function_name()</code> etc.
    </p><p>
      There's also an <code>ellipsis</code> type, and actually, there's a lot.
    </p>
  </td></tr>
  <tr><td><a href="#21"><img id="21" class="slide" src="/assets/images/static_typing/21.png"></a></td><td>
    <p>
      In Python if you <code>import types</code>...
    </p>
  </td></tr>
  <tr><td><a href="#22"><img id="22" class="slide" src="/assets/images/static_typing/22.png"></a></td><td>
    <p>
      ...and you call <code>dir()</code> on <code>types</code>, there's this whole list of things that exist in Python that could have a type, like <code>CodeType</code>, you can see <code>FunctionType</code> is in there, there's all sorts of types.
    </p><p>
      You could instantiate a function with these classes, it's just a class which takes arguments.
      But we don't, because it'd be really messy, but these types are available.
    </p>
  </td></tr>
  <tr><td><a href="#23"><img id="23" class="slide" src="/assets/images/static_typing/23.png"></a></td><td>
    <p>
      When we say that Python is a dynamically typed language, what does it mean?
    </p><p>
      First of all, it means that a variable can be any type.
      If I assign something to be a variable, it can contain any of these types that are available to us.
    </p>
  </td></tr>
  <tr><td><a href="#24"><img id="24" class="slide" src="/assets/images/static_typing/24.png"></a></td><td>
    <p>
      For example, I could <code>import random</code>, and set the variable <code>a</code> to be the random choice between an integer, a float and a string.
    </p><p>
      What is the type of <code>a</code> here if I evaluate this?
    </p>
  </td></tr>
  <tr><td><a href="#25"><img id="25" class="slide" src="/assets/images/static_typing/25.png"></a></td><td>
    <p>
      Well, it depends, it's non-deterministic.
      It depends on which object was randomly chosen from that list.
    </p><p>
      Could be a string, could be int, could be float, doesn't matter.
      That variable can contain any of those types.
    </p>
  </td></tr>
  <tr><td><a href="#26"><img id="26" class="slide" src="/assets/images/static_typing/26.png"></a></td><td>
    <p>
      Dynamic typing also means that the arguments and return values for a function can also be any type as all.
      The same is true for for a variable as it is for a functions arguments as it is for the return value for the function.
    </p>
  </td></tr>
  <tr><td><a href="#27"><img id="27" class="slide" src="/assets/images/static_typing/27.png"></a></td><td>
    <p>
      If I had a function like this, <code>frobnicate</code> which takes three arguments and returns <code>a + b + c</code>, how do we know what types this is going to expect? Does anyone have a guess what <code>a</code>, <code>b</code> and <code>c</code> should be here?
    </p>
  </td></tr>
  <tr><td><a href="#29"><img id="29" class="slide" src="/assets/images/static_typing/29.png"></a></td><td>
    <p>
      If I define the <code>frobnicate</code> function, and I call it with 1, 2, and 3, it correctly adds them all up to 6.
    </p>
  </td></tr>
  <tr><td><a href="#30"><img id="30" class="slide" src="/assets/images/static_typing/30.png"></a></td><td>
    <p>
      But, I can also call this same function with strings.
      And it would concatenate these strings instead.
    </p><p>
      This function would accept either of these types as arguments, and it would still work, right? It's still a valid Python function.
    </p>
  </td></tr>
  <tr><td><a href="#31"><img id="31" class="slide" src="/assets/images/static_typing/31.png"></a></td><td>
    <p>
      What I can't do is mix these types, I can't add integers and strings just with the <code>+</code> operator, so this would result in a <code>TypeError</code>: I'm trying to do something and the types are incompatible.
    </p><p>
      That's confusing, this function is confusing.
      How can we fix it?
    </p>
  </td></tr>
  <tr><td><a href="#32"><img id="32" class="slide" src="/assets/images/static_typing/32.png"></a></td><td>
    <p>
      One thing we could do is write really long and detailed docstrings that outline every single type that the function expects, what they are, and what it returns.
    </p><p>
      Who writes docstrings like this, anybody? For those of you with your hands up, is your employer paying you enough to write docstrings like this?
    </p><p>
      Because it's a lot of work! And while this is great to read, the thing about this is that writing this docstring has zero effect on whether this function is actually being called correctly or not.
    </p><p>
      You're telling the developer that's eventually going to come and try and use it, that this is what you expect, but there's no guarantee that they're actually going to do that.
    </p>
  </td></tr>
  <tr><td><a href="#33"><img id="33" class="slide" src="/assets/images/static_typing/33.png"></a></td><td>
    <p>
      Another thing we could do: we could <code>assert</code> on the type of everything that's passed to this function, do our business logic, and then assert on the return type before we actually return it.
    </p><p>
      I gave this talk once before and I said "nobody does, this, this is insane!" Because the thing is, this actually adds overhead to the execution of this function.
      There's a small cost you have to pay to do all these assertions.
    </p><p>
      And after I gave this talk, someone came up to me and said "yeah, actually, we do do this..." And while it works -- it's a valid way to assert on the types for your function -- it's so many extra lines, and what if you forgot an assertion? It's on you to remember that.
    </p>
  </td></tr>
  <tr><td><a href="#34"><img id="34" class="slide" src="/assets/images/static_typing/34.png"></a></td><td>
    <p>
      What do we do instead? In Python, what we do is called "duck typing"
    </p><p>
      Which means that if it walks like a duck, and it quacks like a duck, it is probably a duck.
    </p>
  </td></tr>
  <tr><td><a href="#35"><img id="35" class="slide" src="/assets/images/static_typing/35.png"></a></td><td>
    <p>
      This means that how we use a variable helps us determine what it's type may be.
    </p><p>
      For example, in this first line, I'm setting <code>foo</code> to be <code>[f(x) for x in bar]</code>.
      We could probably reasonably assume that <code>bar</code> is an iterable, maybe a string, a list, or a set.
    </p><p>
      On the second line, we're comparing <code>bar</code> to zero, so <code>bar</code> is probably a number, like an integer or a float.
      It's unclear, but we have a pretty good idea about what it is.
    </p><p>
      And the last one, that could be a function, it could be a class that's poorly named (doesn't start with a capital letter), but we don't know.
      It could be anything.
    </p>
  </td></tr>
  <tr><td><a href="#36"><img id="36" class="slide" src="/assets/images/static_typing/36.png"></a></td><td>
    <p>
      This brings us to static typing.
      Static typing is basically the opposite of dynamic typing.
      It means that the type of a variable, the arguments to a function and the return type of a function are statically defined and they cannot change, they have to be a specific thing.
    </p><p>
      Here are some examples of that same <code>frobnicate</code> function in other languages, and I'm curious if people can recognize these languages.
    </p>
  </td></tr>
  <tr><td><a href="#37"><img id="37" class="slide" src="/assets/images/static_typing/37.png"></a></td><td>
    <p>
      Here's the first example, anyone know?
    </p><p>
      That's C.
    </p>
  </td></tr>
  <tr><td><a href="#38"><img id="38" class="slide" src="/assets/images/static_typing/38.png"></a></td><td>
    <p>
      How about this one?
    </p><p>
      That's Java, it's a dead giveaway with the <code>public static int</code>.
    </p>
  </td></tr>
  <tr><td><a href="#39"><img id="39" class="slide" src="/assets/images/static_typing/39.png"></a></td><td>
    <p>
      Anyone know this one?
    </p><p>
      This is Rust: Rust has really fine-grained integer types, so this is an unsigned 8-bit integer.
    </p>
  </td></tr>
  <tr><td><a href="#40"><img id="40" class="slide" src="/assets/images/static_typing/40.png"></a></td><td>
    <p>
      How about this one? The <code>number</code> is the hint here.
    </p><p>
      This is TypeScript, which is typed JavaScript.
      In JavaScript there's only one number type, everything is a <code>number</code>, so that's how you know.
    </p>
  </td></tr>
  <tr><td><a href="#41"><img id="41" class="slide" src="/assets/images/static_typing/41.png"></a></td><td>
    <p>
      You can sorta put languages into one of two categories: there are dynamically typed languages, and there are statically typed languages.
    </p>
  </td></tr>
  <tr><td><a href="#42"><img id="42" class="slide" src="/assets/images/static_typing/42.png"></a></td><td>
    <p>
      And I have to put a little asterisk here next to Python here, which is why we're having this talk.
      Because Python is, and was originally, a dynamically typed language, but it is now also kinda statically typed.
    </p><p>
      Also apparently Ruby is going to get a type system kind of like Python's but not until the end of next year, so I won't include it yet.
    </p>
  </td></tr>
  <tr><td><a href="#43"><img id="43" class="slide" src="/assets/images/static_typing/43.png"></a></td><td>
    <p>
      Like I said before: Python is a dynamically typed language, but it can optionally be as statically typed as you want it to be.
    </p><p>
      This wasn't always true.
      When Python was first created, it was purely a dynamically typed language.
    </p>
  </td></tr>
  <tr><td><a href="#44"><img id="44" class="slide" src="/assets/images/static_typing/44.png"></a></td><td>
    <p>
      And the story of Python becoming a language that is optionally statically typed is also <a href="https://dropbox.tech/application/our-journey-to-type-checking-4-million-lines-of-python">the story of type-checking at Dropbox</a>.
    </p><p>
      Dropbox is a large company with millions of lines of Python code.
      At that scale, having that many lines of untyped code is a liability.
      It becomes exponentially harder for your developers to interpret what this code does when they inherit new code bases, when they're doing refactoring, etc.
    </p><p>
      Pretty early on in their journey of having that much Python code, they realized that it's not great that Python is dynamically typed in this case, because it makes it hard for us to work with it.
    </p><p>
      However, there were some things leading up to it as well.
    </p>
  </td></tr>
  <tr><td><a href="#45"><img id="45" class="slide" src="/assets/images/static_typing/45.png"></a></td><td>
    <p>
      The first is <a href="https://www.python.org/dev/peps/pep-3107/">PEP 3107</a>.
      We got this in Python 3.0 in 2006, and this allowed us to do something something like this.
    </p>
  </td></tr>
  <tr><td><a href="#46"><img id="46" class="slide" src="/assets/images/static_typing/46.png"></a></td><td>
    <p>
      I could take a function like this...
    </p>
  </td></tr>
  <tr><td><a href="#47"><img id="47" class="slide" src="/assets/images/static_typing/47.png"></a></td><td>
    <p>
      ...and I could add any metadata that I wanted to the arguments and the return type of this function.
      Anything that's valid Python could be put in after the colon here.
    </p>
  </td></tr>
  <tr><td><a href="#48"><img id="48" class="slide" src="/assets/images/static_typing/48.png"></a></td><td>
    <p>
      And what I would get, if I defined that function and called <code>__annotations__</code> to get that attribute off of it, would be the evaluation of all those annotations, in a <code>dict</code>, including the return annotation.
      Now, these are just made up things, they don't have any real meaning.
    </p>
  </td></tr>
  <tr><td><a href="#49"><img id="49" class="slide" src="/assets/images/static_typing/49.png"></a></td><td>
    <p>
      And that was the thing, it was basically a nice feature, and there were a lot of things that could be done with it.
    </p><p>
      All of them boiled down to "maybe we can provide typing information with this", and there were a lot of different ways we could do that.
    </p><p>
      We could also just use it as documentation, but really it was looking forward to having type annotations for functions.
    </p>
  </td></tr>
  <tr><td><a href="#50"><img id="50" class="slide" src="/assets/images/static_typing/50.png"></a></td><td>
    <p>
      This allows us to actually write a function like this which is actually interesting.
      Here, you can see the type for each argument, and the return type, and then you would have annotations that would tell you what the developer was expecting when they wrote that code.
    </p><p>
      But, it still doesn't give us a way to actually evaluate whether that function's being used correctly, it just gives us annotations, and now an attribute that tells us what those annotations were.
    </p><p>
      And, this is just for functions: can't do variables here at all.
    </p>
  </td></tr>
  <tr><td><a href="#51"><img id="51" class="slide" src="/assets/images/static_typing/51.png"></a></td><td>
    <p>
      Around the same time, Jukka Lehtosalo was working on his PhD thesis at the University of Cambridge.
    </p>
  </td></tr>
  <tr><td><a href="#52"><img id="52" class="slide" src="/assets/images/static_typing/52.png"></a></td><td>
    <p>
      His research was about the unification of statically typed and dynamically typed languages.
    </p>
  </td></tr>
  <tr><td><a href="#53"><img id="53" class="slide" src="/assets/images/static_typing/53.png"></a></td><td>
    <p>
      His goal was to be able to use the same language for everything from really tiny scripts, to a sprawling multi-million line codebase, and add as much typing as you want.
    </p>
  </td></tr>
  <tr><td><a href="#54"><img id="54" class="slide" src="/assets/images/static_typing/54.png"></a></td><td>
    <p>
      He wanted to have this gradual growth from something that was completely untyped, and allow you to slowly mix in and add static typing to it.
    </p><p>
      Sounds kind of interesting. Would be great to not have to do it all at once, especially if you have millions of lines.
    </p>
  </td></tr>
  <tr><td><a href="#55"><img id="55" class="slide" src="/assets/images/static_typing/55.png"></a></td><td>
    <p>
      In 2011 he published his PhD thesis, and basically his conclusion was this:
    </p>
  </td></tr>
  <tr><td><a href="#56"><img id="56" class="slide" src="/assets/images/static_typing/56.png"></a></td><td>
    <p>
      If you try to add a static type system to a dynamically typed language, it could be totally invasive.
      You'd have to change every tool in the ecosystem, every interpreter, everything that checks syntax, etc.
      This was his conclusion.
    </p>
  </td></tr>
  <tr><td><a href="#57"><img id="57" class="slide" src="/assets/images/static_typing/57.png"></a></td><td>
    <p>
      However, he proposed, that if you could create an optional, pluggable type system  that doesn't actually affect the runtime of the program,
      this could be added to everything without adding significant burden to the ecosystem.
    </p>
  </td></tr>
  <tr><td><a href="#58"><img id="58" class="slide" src="/assets/images/static_typing/58.png"></a></td><td>
    <p>
      This sounds really great. What he did was take his PhD work, and went to PyCon US in 2013, and he introduced something called Mypy.
    </p> <p>
      If you've heard of Mypy before, what he introduced was not what you've heard of before.
    </p>
  </td></tr>
  <tr><td><a href="#59"><img id="59" class="slide" src="/assets/images/static_typing/59.png"></a></td><td>
    <p>
      In the abstract for this talk, he describes Mypy as "an experimental variant of Python that supports writing programs that seamlessly mix static and dynamic typing".
    </p> <p>
      This wasn't a just a type checker (although it <i>included</i> a type checker), it was actually a variant of Python.
    </p><p>
      In his research, he couldn't use Python directly, so he created a new language that kinda looked like Python that allowed him to actually do his research about type systems.
    </p>
  </td></tr>
  <tr><td><a href="#60"><img id="60" class="slide" src="/assets/images/static_typing/60.png"></a></td><td>
    <p>
      Mypy the language looked like this. It kinda looks like Python, but you see that it has <code>int fib</code>, that's defining the type of that function, etc.
    </p><p>
      The point is, Python at the time, even with function annotations, it wasn't enough for him to actually use Python to do static typing research.
    </p>
  </td></tr>
  <tr><td><a href="#61"><img id="61" class="slide" src="/assets/images/static_typing/61.png"></a></td><td>
    <p>
      He presented his project at PyCon, and he said afterwards, he chatted with Guido about it, and Guido convinced him to get rid of this variant of Python, to just try to do it in pure Python, since it would make a lot more sense, and we'd get some benefit from it as well.
    </p><p>
      So the variant went away, and Mypy became just the type checker that was included with it, and that is actually what we think of and what we'll see become Mypy today.
    </p>
  </td></tr>
  <tr><td><a href="#62"><img id="62" class="slide" src="/assets/images/static_typing/62.png"></a></td><td>
    <p>
      Shortly after that, Guido published <a href="https://www.python.org/dev/peps/pep-0483/">PEP 483</a>, which is his theory of type hints: the idea of how types and static typing should work in Python.
      This is some really broad and general ideas about typing in Python in general.
    </p>
  </td></tr>
  <tr><td><a href="#63"><img id="63" class="slide" src="/assets/images/static_typing/63.png"></a></td><td>
    <p>
      The first tenet of this was that typing should be optional, and you can see how this is sort of coming from Jukka's research. Essentially: adding an annotation to some Python code shouldn't affect the runtime. It should have zero effect on the actual runtime of your program.
    </p><p>
      This means that an annotated function should behave exactly the same as one that doesn't have any type annotations.
    </p><p>
      I think this is representative of some lessons we learned from the transition from Python 2 to Python 3: we want this to be an easy transition from untyped to typed code.
    </p>
  </td></tr>
  <tr><td><a href="#64"><img id="64" class="slide" src="/assets/images/static_typing/64.png"></a></td><td>
    <p>
      And we also want to be able to do it piecemeal: like Jukka said in his paper, we want to do gradual typing, you want to be able to add typing to certain files in your codebase and not have to do it all at once.
    </p>
  </td></tr>
  <tr><td><a href="#65"><img id="65" class="slide" src="/assets/images/static_typing/65.png"></a></td><td>
    <p>
      In addition, we should have variable annotation: just functions is not enough, we need a way to specify the types for individual variables in Python as well.
    </p>
  </td></tr>
  <tr><td><a href="#66"><img id="66" class="slide" src="/assets/images/static_typing/66.png"></a></td><td>
    <p>
     That means that in addition to having the function annotation...
    </p>
  </td></tr>
  <tr><td><a href="#67"><img id="67" class="slide" src="/assets/images/static_typing/67.png"></a></td><td>
    <p>
      ...we should be able to say that the type of this variable I'm assigning to is an integer, and then return that.
    </p>
  </td></tr>
  <tr><td><a href="#68"><img id="68" class="slide" src="/assets/images/static_typing/68.png"></a></td><td>
    <p>
      This also means that we can do type hinting for Python 2.
      As long as we have this sort of comment notation for variables, even those that have old versions of Python should be able to use static typing.
      This allowed us to do all the same types of annotations before function annotations existed in Python 3.
    </p>
  </td></tr>
  <tr><td><a href="#69"><img id="69" class="slide" src="/assets/images/static_typing/69.png"></a></td><td>
    <p>
      That means I can have the same function in Python 2 and Python 3, and just by turning that function annotation into a comment, it has the exact same behavior.
    </p>
  </td></tr>
  <tr><td><a href="#70"><img id="70" class="slide" src="/assets/images/static_typing/70.png"></a></td><td>
    <p>
      This PEP also introduced some special type constructs, these are some fundamental things we need to do static typing.
    </p>
  </td></tr>
  <tr><td><a href="#71"><img id="71" class="slide" src="/assets/images/static_typing/71.png"></a></td><td>
    <p>
      These take all the existing types and allows us to construct new types as well.
    </p><p>
      These are types like <code>Any</code>, which would match the type of anything at all, <code>Union</code>, which is the union of two types, <code>Optional</code>, which is an alias for the union of <code>NoneType</code> and any existing type, <code>Tuple</code>, <code>Callable</code>, etc., which match the corresponding objects in Python.
    </p>
  </td></tr>
  <tr><td><a href="#72"><img id="72" class="slide" src="/assets/images/static_typing/72.png"></a></td><td>
    <p>
      Then we could write something like this: a <code>frobnicate</code> function that takes an integer, an integer, and then optionally could take an int or a float, and then the return value, again, could be either an int or a float.
    </p><p>
      Once we have these special type constructs, we have a more powerful type system here.
    </p>
  </td></tr>
  <tr><td><a href="#73"><img id="73" class="slide" src="/assets/images/static_typing/73.png"></a></td><td>
    <p>
      The PEP also defines some container types, which allows us to define types inside container classes like dictionaries and lists.
    </p>
  </td></tr>
  <tr><td><a href="#74"><img id="74" class="slide" src="/assets/images/static_typing/74.png"></a></td><td>
    <p>
      That would look something like this.
      If I had a list of integers, I could define the type of that container class and the values that will be stored inside it, and the same for dictionaries: I could have a dictionary where they key is always a string and the value is always an integer.
    </p>
  </td></tr>
  <tr><td><a href="#75"><img id="75" class="slide" src="/assets/images/static_typing/75.png"></a></td><td>
    <p>
      The PEP also gives us generic types, for things that behave in a generic way.
    </p><p>
      In Python we have things like an iterable.
      An iterable is this whole class of objects that have the features of something that can be iterated on.
    </p>
  </td></tr>
  <tr><td><a href="#76"><img id="76" class="slide" src="/assets/images/static_typing/76.png"></a></td><td>
    <p>
     We also have types like <code>Iterable</code> that we can use to type things which we don't really care if it's a list, or if it's a dict: we just want to be able to iterate over it.
    </p>
  </td></tr>
  <tr><td><a href="#77"><img id="77" class="slide" src="/assets/images/static_typing/77.png"></a></td><td>
    <p>
      Finally, with this theory of type hints, we can do type aliases using <code>Union</code>.
    </p>
  </td></tr>
  <tr><td><a href="#78"><img id="78" class="slide" src="/assets/images/static_typing/78.png"></a></td><td>
    <p>
     So if we wanted to be more like JavaScript, we could have a single number type that unifies all numbers in Python.
    </p>
  </td></tr>
  <tr><td><a href="#79"><img id="79" class="slide" src="/assets/images/static_typing/79.png"></a></td><td>
    <p>
     That was the theory of type hints, and then we had <a href="https://www.python.org/dev/peps/pep-0484/">PEP 484</a>, which standardizes everything in PEP 483, and basically standardizes around what Mypy was currently doing.
    </p><p>
      In short, this PEP was "how to build a type checker for Python".
      It introduces a <code>typing</code> module, it introduces a lot of details about edge cases and specific use cases.
      It leans really heavily on what Mypy was already doing.
    </p>
  </td></tr>
  <tr><td><a href="#80"><img id="80" class="slide" src="/assets/images/static_typing/80.png"></a></td><td>
    <p>
      We got that in Python 3.5, which had PEP 484 support, including the <code>typing</code> module.
    </p>
  </td></tr>
  <tr><td><a href="#81"><img id="81" class="slide" src="/assets/images/static_typing/81.png"></a></td><td>
    <p>
      Then we got <a href="https://www.python.org/dev/peps/pep-0526/">PEP 526</a>, which let us do inline variable annotations.
    </p>
  </td></tr>
  <tr><td><a href="#82"><img id="82" class="slide" src="/assets/images/static_typing/82.png"></a></td><td>
    <p>
      This allowed us to do something like this: before, for variables, we had to use these type comments...
    </p>
  </td></tr>
  <tr><td><a href="#83"><img id="83" class="slide" src="/assets/images/static_typing/83.png"></a></td><td>
    <p>
      ...and now we can do it inline. So <code>primes</code> would look like this.
    </p>
  </td></tr>
  <tr><td><a href="#84"><img id="84" class="slide" src="/assets/images/static_typing/84.png"></a></td><td>
    <p>
      One problem with the comment annotation syntax was that it's hard to initialize a type for a variable that doesn't have a value yet.
    </p>
    <p>
      With inline variable annotations, we could do this, where just say "this variable is a string, I don't care, it doesn't have a value yet"
    </p>
  </td></tr>
  <tr><td><a href="#85"><img id="85" class="slide" src="/assets/images/static_typing/85.png"></a></td><td>
    <p>
      And the same thing for class types. Here, <code>stats</code> is a class variable, I can now annotate it correctly with inline annotations.
    </p>
  </td></tr>
  <tr><td><a href="#86"><img id="86" class="slide" src="/assets/images/static_typing/86.png"></a></td><td>
    <p>
      We got that in Python 3.6, and that was <i>almost</i> everything we needed to do static typing in Python, but we needed a type checker.
    </p> <p>
      And that was Mypy, and it's the last piece of the puzzle. It's not included with core Python, it's a third-party tool.
    </p>
  </td></tr>
  <tr><td><a href="#87"><img id="87" class="slide" src="/assets/images/static_typing/87.png"></a></td><td>
    <p>
      The idea is that we have a couple different types of type checkers: we have either dynamic or static type checkers.
    </p><p>
      A static type checker is going to type-check your code at rest.
      It's going to look at your source and not actually evaluate any of it, it's going to do it totally statically.
      Whereas a dynamic type checker is going to be kind of like those asserts we were doing before: it's going to happen at runtime, it's going to check those types as your program executes.
    </p> <p>
      So Mypy is a static type checker for statically typed Python.
    </p>
  </td></tr>
  <tr><td><a href="#88"><img id="88" class="slide" src="/assets/images/static_typing/88.png"></a></td><td>
    <p>
      Like I said, it's just a tool, you can <code>pip install</code> it, <a href="https://pypi.org/p/mypy">it's available on PyPI</a>.
    </p>
  </td></tr>
  <tr><td><a href="#89"><img id="89" class="slide" src="/assets/images/static_typing/89.png"></a></td><td>
    <p>
      If you run it, it looks something like this: you install it, create a file with some static types, and if they're wrong, it'll warn you. It will tell you "hey, you told me this argument should be an integer, but you're calling it with a string, that's a type error.
    </p>
  </td></tr>
  <tr><td><a href="#90"><img id="90" class="slide" src="/assets/images/static_typing/90.png"></a></td><td>
    <p>
      There are actually a bunch of type checker besides Mypy, like I said, there are static and dynamic ones.
      The static ones kind of align with all the large Python shops that exist, so Mypy is mostly owned by Dropbox these days, Google has <a href="https://pypi.org/p/pytype/">Pytype</a>, Facebook has Pyre, Microsoft has Pyright.
    </p><p>
      PyCharm actually has a type checker built into the IDE.
      And actually you can use any of these type checkers with whatever your IDE or development environment is as well, most of them integrate into some Python environment.
    </p><p>
      Disclaimer, I work at Google, so one of the questions that I often get about type checking is "what is the difference?" Like, if these all implement PEP 484, what's the difference between them. I've actually only used Mypy and Pytype, so I'll tell you what the difference between those is.
    </p><p>
      The answer's not a whole lot, basically it comes down to a philosophy.
    </p>
  </td></tr>
  <tr><td><a href="#92"><img id="92" class="slide" src="/assets/images/static_typing/92.png"></a></td><td>
    <p>
      The philosophy is that Pytype will only give you a type error if it will actually become a runtime exception.
      Whereas Mypy is going to be a lot more strict about the actual usage of types. I'll show you some examples.
    </p>
  </td></tr>
  <tr><td><a href="#93"><img id="93" class="slide" src="/assets/images/static_typing/93.png"></a></td><td>
    <p>
      Here I have two functions: one returns a string, and the other takes the call to that function and adds it to an integer.
    </p>
  </td></tr>
  <tr><td><a href="#94"><img id="94" class="slide" src="/assets/images/static_typing/94.png"></a></td><td>
    <p>
      If I were to run this, it would be a type error: I'm trying to add a string to an integer, and that's a problem.
    </p>
  </td></tr>
  <tr><td><a href="#96"><img id="96" class="slide" src="/assets/images/static_typing/96.png"></a></td><td>
    <p>
      If I run it with Mypy, it actually passes. It says that this is fine, and the reason is because it is unable to do type inference across multiple functions.
    </p>
  </td></tr>
  <tr><td><a href="#98"><img id="98" class="slide" src="/assets/images/static_typing/98.png"></a></td><td>
    <p>
      However, if I ran this with Pytype, it would actually say "yeah, if you ran this, at runtime you would get a type error, and that's a problem".
      And you would get an error.
    </p>
    <p>
      And actually the reverse is true as well. Pytype is going to be more lenient in situations where it's not going to produce a runtime error.
    </p>
  </td></tr>
  <tr><td><a href="#99"><img id="99" class="slide" src="/assets/images/static_typing/99.png"></a></td><td>
    <p>
      Here's an example of a function, it takes a list, the list has at string inside of it, and I append an integer in it, iterate over it, and print it.
    </p>
    <p>
      This will succeed if I try to run this.
      It's totally valid, although it might be a little confusing to our developers to mix strings and integers here.
    </p>
  </td></tr>
  <tr><td><a href="#100"><img id="100" class="slide" src="/assets/images/static_typing/100.png"></a></td><td>
    <p>
      If I run this, it correctly prints a list of strings.
    </p>
  </td></tr>
  <tr><td><a href="#101"><img id="101" class="slide" src="/assets/images/static_typing/101.png"></a></td><td>
    <p>
      Pytype says there's no errors here.
    </p>
  </td></tr>
  <tr><td><a href="#102"><img id="102" class="slide" src="/assets/images/static_typing/102.png"></a></td><td>
    <p>
      But Mypy's going to complain because you're trying to append an integer to a list of strings and it's incompatible.
    </p>
  </td></tr>
  <tr><td><a href="#103"><img id="103" class="slide" src="/assets/images/static_typing/103.png"></a></td><td>
    <p>
      You might now say: "why?"
    </p>
    <p>
      This is all great, it's great that we have this in Python, why do I want to use it?
    </p>
  </td></tr>
  <tr><td><a href="#104"><img id="104" class="slide" src="/assets/images/static_typing/104.png"></a></td><td>
    <p>
      First I'll say when you shouldn't use static typing, and the answer is: basically never.
    </p>
    <p>
      It's not going to hurt you, it's not painful to use.
    </p>
  </td></tr>
  <tr><td><a href="#105"><img id="105" class="slide" src="/assets/images/static_typing/105.png"></a></td><td>
    <p>
      One case when you might not want to use static typing is if you're going to use it to replace your unit tests. Static typing is not a replacement for unit tests.
    </p>
    <p>
      A lot of time unit tests end up being something that ends up looking like you're the types of your program, but it's not. And actually you probably need both static typing and unit tests simultaneously.
    </p>
  </td></tr>
  <tr><td><a href="#107"><img id="107" class="slide" src="/assets/images/static_typing/107.png"></a></td><td>
    <p>
      When should you use static typing? Basically, use it as much as possible. Use it liberally, use it in these situations:
    </p>
  </td></tr>
  <tr><td><a href="#108"><img id="108" class="slide" src="/assets/images/static_typing/108.png"></a></td><td>
    <p>
      Maybe when you're millions-of-lines scale.
      Like I said before, that much dynamically typed Python is a liability, and so if you have millions of lines of Python code, you probably already know this, but you should probably start statically typing it.
    </p>
  </td></tr>
  <tr><td><a href="#109"><img id="109" class="slide" src="/assets/images/static_typing/109.png"></a></td><td>
    <p>
      Dropbox found that at their scale, dynamic typing produced needlessly hard to understand code that impacted developer productivity.
    </p>
    <p>
      That's why all these big shops like Google and Facebook have invested in static typing, because it actually makes their developers lives easier.
      And the lack of static typing is a liability at that scale.
    </p>
  </td></tr>
  <tr><td><a href="#110"><img id="110" class="slide" src="/assets/images/static_typing/110.png"></a></td><td>
    <p>
      You can imagine a graph that looks like this, where as your lines of code go up, your desire to add type annotations goes up, and the ease of doing it goes down.
    </p>
  </td></tr>
  <tr><td><a href="#111"><img id="111" class="slide" src="/assets/images/static_typing/111.png"></a></td><td>
    <p>
      You are probably here, unless you're Facebook, Dropbox or Google.
    </p>
  </td></tr>
  <tr><td><a href="#112"><img id="112" class="slide" src="/assets/images/static_typing/112.png"></a></td><td>
    <p>
      This is a good time to add static typing.
    </p>
  </td></tr>
  <tr><td><a href="#113"><img id="113" class="slide" src="/assets/images/static_typing/113.png"></a></td><td>
    <p>
      This is probably when you're actually going to do it, but keep that in mind when you're evaluating when to start adding static typing.
      It's easier to do it earlier.
    </p>
  </td></tr>
  <tr><td><a href="#114"><img id="114" class="slide" src="/assets/images/static_typing/114.png"></a></td><td>
    <p>
      You should use static typing when your code is confusing.
    </p><p>
      Let's be honest, we've all written confusing code.
      You can think of static typing as machine-verified documentation.
    </p><p>
      You add typing to your Python function that is extremely confusing, and it will tell your developers what that function should expect and return.
      And it will also allow you to verify that it's actually being called that way.
    </p><p>
      If you feel the need to document the input and output of a function, that's probably a hint that you should just statically type it.
    </p>
  </td></tr>
  <tr><td><a href="#115"><img id="115" class="slide" src="/assets/images/static_typing/115.png"></a></td><td>
    <p>
      You should use static typing when your code is for pubic consumption.
      Let's say you're publishing a module on PyPI: adding type annotations help the developers who use your module know how to use it.
      And it also means that if they're using static typing in their codebase, they'll really appreciate that you're publishing types for your codebase as well.
    </p>
  </td></tr>
  <tr><td><a href="#116"><img id="116" class="slide" src="/assets/images/static_typing/116.png"></a></td><td>
    <p>
      Another good time to use static typing is before doing a big migration or doing a big refactor.
      Go and add static types to everything that you're about to change, and then change it, and see if you get a bunch of type errors.
      Because if you do, it means that you're calling some function wrong, or that you've missed some part of your migration.
    </p>
  </td></tr>
  <tr><td><a href="#117"><img id="117" class="slide" src="/assets/images/static_typing/117.png"></a></td><td>
    <p>
      And finally, you can also use static typing to just experiment with static typing.
      Like I said, it doesn't hurt, it's pretty easy to just add some static types, as long as you're in the latest version of Python that supports it.
    </p>
  </td></tr>
  <tr><td><a href="#118"><img id="118" class="slide" src="/assets/images/static_typing/118.png"></a></td><td>
    <p>
      To conclude: here's how you can use static typing in Python in just five easy steps.
    </p>
  </td></tr>
  <tr><td><a href="#119"><img id="119" class="slide" src="/assets/images/static_typing/119.png"></a></td><td>
    <p>
      First, optionally, you can migrate to a newer version of Python.
    </p>
    <p>
      Like I said, type comments will allow you to statically type older Python 2 code, but really we should probably all be migrating to Python 3.6 or above.
      We now have Python 3.8, so you should at least be on 3.6.
    </p>
  </td></tr>
  <tr><td><a href="#120"><img id="120" class="slide" src="/assets/images/static_typing/120.png"></a></td><td>
    <p>
      Second, you can install a type-checker locally.
    </p>
    <p>
      I don't care which one it is, install one, install multiple, it doesn't matter, and integrate it into your IDE.
      This will allow you to start getting type notifications in your code as soon as you add just one line of static typing.
    </p>
  </td></tr>
  <tr><td><a href="#121"><img id="121" class="slide" src="/assets/images/static_typing/121.png"></a></td><td>
    <p>
      And then you can start optionally typing your codebase.
    </p>
    <p>
      You can start with the hardest function you have, the one that's the most impossible to understand, or you can start with the easiest one, the simplest function would be the easiest one to type.
      Just pick a critical area and start there.
    </p>
  </td></tr>
  <tr><td><a href="#122"><img id="122" class="slide" src="/assets/images/static_typing/122.png"></a></td><td>
    <p>
      And then, what you can do when you have a little static typing is that you can start running your same type checker with your linting.
    </p><p>
      I'm assuming you're doing linting, everyone's probably just running <a href="https://pypi.org/p/black"><code>black</code></a> now.
      Just add type checking as well, just run Mypy at the same time.
    </p>
  </td></tr>
  <tr><td><a href="#123"><img id="123" class="slide" src="/assets/images/static_typing/123.png"></a></td><td>
    <p>
      And finally you can convince all your coworkers to join you in the glory of static typing.
    </p><p>
      If you need help convincing them, you can share this talk with them. 😉
    </p>
  </td></tr>
  <tr><td><a href="#124"><img id="124" class="slide" src="/assets/images/static_typing/124.png"></a></td><td>
    <p>
      Thanks!
    </p>
    <ul>
      <li>
        GitHub: <a href="https://github.com/di"><code>@di</code></a>
      </li>
      <li>
        Social: <a href="https://di.social"><code>@di.dev</code></a>
      </li>
    </ul>
  </td></tr>
</table>
</div>
