---
layout : post
category : talks
title: "Inside the Cheeseshop: How Python Packaging Works"
tags : [python, packaging, pypi]
venues:
  - date: 2018-10-06 00:00:00 -6000
    venue_url: "https://2018.pygotham.org/talks/inside-the-cheeseshop-how-python-packaging-works/"
    venue: "PyGotham 2018"
    location: "New York NY"
  - date: 2018-07-28 00:00:00 -6000
    venue_url: "https://www.pyohio.org/2018/schedule/presentation/46/"
    venue: "PyOhio 2018"
    location: "Columbus OH"
    links:
      video: "https://www.youtube.com/watch?v=YItZVgRDrjM"
  - date: 2018-07-11 00:00:00 -6000
    venue_url: "https://scipy2018.scipy.org/ehome/index.php?eventid=299527&"
    venue: "SciPy 2018"
    location: "Austin TX"
    links:
      video: "https://www.youtube.com/watch?v=na0hQI5Ep5E"
  - date: 2018-05-12 00:00:00 -0600
    venue_url: "https://us.pycon.org/2018/schedule/presentation/148/"
    venue: "PyCon 2018"
    location: "Cleveland OH"
    links:
      video: "https://www.youtube.com/watch?v=AQsZsgJ30AE"
image : assets/images/cheeseshop/34.png
description : 'This talk identifies the key tools in the Python Packaging ecosystem, what they are used for, why they exist, their history, and what the future has in store for them.'
---

##### This is a transcript of a talk I gave a few times in 2018.

<div class="slides">
<table>
  <tr><td><a href="#2"><img id="2" class="slide" src="/assets/images/cheeseshop/2.png"></a></td><td>
    <p>
      Hi, I'm Dustin Ingram.
    </p>
  </td></tr>
  <tr><td><a href="#3"><img id="3" class="slide" src="/assets/images/cheeseshop/3.png"></a></td><td>
    <p>
      I'm a member of the Python Packaging Working Group, the Python Packaging
      Authority, I'm a maintainer, contributor and administrator of the Python
      Package Index, and I'm a developer advocate at Google.
    </p>
  </td></tr>
  <tr><td><a href="#4"><img id="4" class="slide" src="/assets/images/cheeseshop/4.png"></a></td><td>
    <p>
      I had a pretty hard time coming up with the title for this talk.
    </p>
    <p>
      Not because naming things is hard (although, naming things <i>is</i> hard.)
    </p>
    <p>
      The reason I had a hard time coming up with the title of this talk is
      because I knew I wanted to talk about Python Packaging, but a lot of
      people have already given talks about Python Packaging.
    </p>
    <p>
      So many, in fact, that every time I came up with a title for this talk, it
      seemed like it had already been used.
    </p>
  </td></tr>
  <tr><td><a href="#5"><img id="5" class="slide" src="/assets/images/cheeseshop/5.png"></a></td><td>
    <p>
      At first I thought, what is the core of Python Packaging? I'll call my
      talk "Python Packaging: Getting the Code You Wrote To the People That
      Want It Using the Same Language You Wrote It In".
    </p>
  </td></tr>
  <tr><td><a href="#6"><img id="6" class="slide" src="/assets/images/cheeseshop/6.png"></a></td><td>
    <p>
      But that talk has already been given!
    </p>
    <p>
      And that title's pretty long, so I thought maybe I should do something
      more clickbaity.
    </p>
  </td></tr>
  <tr><td><a href="#7"><img id="7" class="slide" src="/assets/images/cheeseshop/7.png"></a></td><td>
    <p>
      Like, "Python Packaging, In Just Five Easy Steps!"
    </p>
  </td></tr>
  <tr><td><a href="#8"><img id="8" class="slide" src="/assets/images/cheeseshop/8.png"></a></td><td>
    <p>
      But that's been done!
    </p>
    <p>
      I thought maybe I could one-up him.
    </p>
  </td></tr>
  <tr><td><a href="#9"><img id="9" class="slide" src="/assets/images/cheeseshop/9.png"></a></td><td>
    <p>
      I'll do "Python Packaging, In Just FOUR Easy Steps!"
    </p>
  </td></tr>
  <tr><td><a href="#10"><img id="10" class="slide" src="/assets/images/cheeseshop/10.png"></a></td><td>
    <p>
      He did that as well!
    </p>
  </td></tr>
  <tr><td><a href="#11"><img id="11" class="slide" src="/assets/images/cheeseshop/11.png"></a></td><td>
    <p>
      Perhaps I should be encouraging about Python Packaging: "Python
      Packaging: It's Relatively Painless Now, Go Ahead And Use It".
    </p>
  </td></tr>
  <tr><td><a href="#12"><img id="12" class="slide" src="/assets/images/cheeseshop/12.png"></a></td><td>
    <p>
      Nope, this talk has been given.
    </p>
    <p>
      And "relatively painless" is still painful, so maybe I should instead try
      to install confidence that it's improving.
    </p>
  </td></tr>
  <tr><td><a href="#13"><img id="13" class="slide" src="/assets/images/cheeseshop/13.png"></a></td><td>
    <p>
      "Python Packaging, We're Still Trying To Make It Better"
    </p>
  </td></tr>
  <tr><td><a href="#14"><img id="14" class="slide" src="/assets/images/cheeseshop/14.png"></a></td><td>
    <p>
      Nope.
    </p>
  </td></tr>
  <tr><td><a href="#15"><img id="15" class="slide" src="/assets/images/cheeseshop/15.png"></a></td><td>
    <p>
      Maybe I should take a stronger approach: "Python Packaging: Let's Just
      Throw It All Away And Start Over From Scratch".
    </p>
  </td></tr>
  <tr><td><a href="#16"><img id="16" class="slide" src="/assets/images/cheeseshop/16.png"></a></td><td>
    <p>
      It's been done!
    </p>
  </td></tr>
  <tr><td><a href="#17"><img id="17" class="slide" src="/assets/images/cheeseshop/17.png"></a></td><td>
    <p>
      Maybe the problem is <i>too much</i> has changed? I'll do "Python
      Packaging: Let Me Just Get You Up To Speed On Everything That's Changed
      Since Last Time".
    </p>
  </td></tr>
  <tr><td><a href="#18"><img id="18" class="slide" src="/assets/images/cheeseshop/18.png"></a></td><td>
    <p>
      Already done.
    </p>
  </td></tr>
  <tr><td><a href="#19"><img id="19" class="slide" src="/assets/images/cheeseshop/19.png"></a></td><td>
    <p>
      Then I figured, maybe not everyone cares about everything in packaging,
      I'll do "Python Packaging: There's A Lot Of Stuff Here, You Might Not
      Need All Of It".
    </p>
  </td></tr>
  <tr><td><a href="#20"><img id="20" class="slide" src="/assets/images/cheeseshop/20.png"></a></td><td>
    <p>
      Already a talk.
    </p>
  </td></tr>
  <tr><td><a href="#21"><img id="21" class="slide" src="/assets/images/cheeseshop/21.png"></a></td><td>
    <p>
      Maybe instead I should just keep it simple: "Python Packaging, In the
      Simplest Terms Possible, For Anyone That Cares".
    </p>
  </td></tr>
  <tr><td><a href="#22"><img id="22" class="slide" src="/assets/images/cheeseshop/22.png"></a></td><td>
    <p>
      It exists.
    </p>
  </td></tr>
  <tr><td><a href="#23"><img id="23" class="slide" src="/assets/images/cheeseshop/23.png"></a></td><td>
    <p>
      Maybe even simpler? "Python Packaging, So Easy A Caveman Could Do It".
    </p>
  </td></tr>
  <tr><td><a href="#24"><img id="24" class="slide" src="/assets/images/cheeseshop/24.png"></a></td><td>
    <p>
      I'm really starting to run out of options at this point.
    </p>
  </td></tr>
  <tr><td><a href="#25"><img id="25" class="slide" src="/assets/images/cheeseshop/25.png"></a></td><td>
    <p>
      Maybe I should stick to something unique about my experience.
    </p>
    <p>
      "Hello. I Am a PyPI Maintainer. At the Very Least, I Should Be Able To
      Tell You How To Use PyPI".
    </p>
  </td></tr>
  <tr><td><a href="#26"><img id="26" class="slide" src="/assets/images/cheeseshop/26.png"></a></td><td>
    <p>
      OK, one last ditch effort.
    </p>
  </td></tr>
  <tr><td><a href="#29"><img id="29" class="slide" src="/assets/images/cheeseshop/29.png"></a></td><td>
    <p>
      I'll do "Python Packaging", but Indiana Jones-themed, for some reason...
      and I'll do it in French.
    </p>
    <p>
      There's no way this has been done before.
    </p>
  </td></tr>
  <tr><td><a href="#30"><img id="30" class="slide" src="/assets/images/cheeseshop/30.png"></a></td><td>
    <p>
      ...
    </p>
  </td></tr>
  <tr><td><a href="#31"><img id="31" class="slide" src="/assets/images/cheeseshop/31.png"></a></td><td>
    <p>
      So it really seems like everything that could be said about Python
      Packaging has already been said.
    </p>
    <p>
      At this point I should probably just give you a list of links to these
      talks on YouTube, and you can go home and watch them at 2x speed.
    </p>
  </td></tr>
  <tr><td><a href="#32"><img id="32" class="slide" src="/assets/images/cheeseshop/32.png"></a></td><td>
    <p>
      And I can just wrap this talk up now.
    </p>
  </td></tr>
  <tr><td><a href="#33"><img id="33" class="slide" src="/assets/images/cheeseshop/33.png"></a></td><td>
    <p>
      In the end, I picked this title, which is really awful, for a number of
      reasons.
    </p>
  </td></tr>
  <tr><td><a href="#34"><img id="34" class="slide" src="/assets/images/cheeseshop/34.png"></a></td><td>
    <p>
      First of all, it's got an obscure reference to something that makes no
      sense. Why am I talking about a cheese shop?
    </p>
    <p>
      I know nothing about cheese.
    </p>
  </td></tr>
  <tr><td><a href="#35"><img id="35" class="slide" src="/assets/images/cheeseshop/35.png"></a></td><td>
    <p>
      Second, "Python Packaging" is an incredibly broad and complex subject.
      Trying to explain how it works is perhaps a lost cause.
    </p>
  </td></tr>
  <tr><td><a href="#36"><img id="36" class="slide" src="/assets/images/cheeseshop/36.png"></a></td><td>
    <p>
      And third, I'm making the assumption that Python Packaging actually
      works! Which has, historically, been the biggest complaint about the
      topic
    </p>
    <p>
      If you can't read the caption, it says "My Python environment has become
      so degraded that my laptop has been declared a superfund site".
    </p>
    <p>
      But here's the thing, I think Python Packaging actually works great, and
      we've just gotten used to how good we have it.
    </p>
  </td></tr>
  <tr><td><a href="#37"><img id="37" class="slide" src="/assets/images/cheeseshop/37.png"></a></td><td>
    <p>
      So I really truly do want to do some Python Packaging archaeology with you
      all. I want to talk about the evolution of packaging through the years,
      to provide some context for why things are the way they are
    </p>
    <p>
      And about how at each step, we had a new problem to solve, then a new
      solution for that problem, which begat a new problem, etc.
    </p>
  </td></tr>
  <tr><td><a href="#38"><img id="38" class="slide" src="/assets/images/cheeseshop/38.png"></a></td><td>
    <p>
      So let's go back in time, back to a time when Python was brand new and
      everything we're familiar with today didn't exist. Back to the beginning
      where there was just python
    </p>
  </td></tr>
  <tr><td><a href="#39"><img id="39" class="slide" src="/assets/images/cheeseshop/39.png"></a></td><td>
    <p>
      Pretty much as soon as there was Python, there was something written in
      Python
    </p>
    <p>
      Let's pretend you're the author of this totally awesome library. Nice
      work! but really, at the moment, this code is only really useful for you.
    </p>
  </td></tr>
  <tr><td><a href="#40"><img id="40" class="slide" src="/assets/images/cheeseshop/40.png"></a></td><td>
    <p>
      So you have a problem: how do you get code to users?
    </p>
    <p>
      This is really the fundamental problem of packaging.
    </p>
    <p>
      Maybe you talk to your friends, and say "Hey, I have this totally awesome
      library".
    </p>
  </td></tr>
  <tr><td><a href="#41"><img id="41" class="slide" src="/assets/images/cheeseshop/41.png"></a></td><td>
    <p>
      You could email it to someone every time you found someone new that
      wanted it. But that would pretty quickly become a pain.
    </p>
  </td></tr>
  <tr><td><a href="#42"><img id="42" class="slide" src="/assets/images/cheeseshop/42.png"></a></td><td>
    <p>
      You could put it up on your website somewhere with a link to download.
      This is nice because you could also add some documentation, etc.
    </p>
    <p>
      But how will people find it if they want it?
    </p>
  </td></tr>
  <tr><td><a href="#43"><img id="43" class="slide" src="/assets/images/cheeseshop/43.png"></a></td><td>
    <p>
      Python was first released in 1991. Google wouldn't be around for another
      seven years.
    </p>
  </td></tr>
  <tr><td><a href="#44"><img id="44" class="slide" src="/assets/images/cheeseshop/44.png"></a></td><td>
    <p>
      This leads us to a new problem: how do we find Python Code?
    </p>
    <p>
      So what we need is a place where people can go to find interesting Python
      code... some sort of "index" for "python packages"... I think we'll call
      it...
    </p>
  </td></tr>
  <tr><td><a href="#45"><img id="45" class="slide" src="/assets/images/cheeseshop/45.png"></a></td><td>
    <p>
      The Vaults of Parnassus.
    </p>
  </td></tr>
  <tr><td><a href="#46"><img id="46" class="slide" src="/assets/images/cheeseshop/46.png"></a></td><td>
    <p>
      This was the first index for Python Software. It was literally an index,
      which just linked to... <i>something</i>... on other peoples websites.
    </p>
    <p>
      I hesitate to the word "package" here, because at this point what a
      "package" is, is really loosely defined.  The end result is just whatever
      those people felt like putting on their website.
    </p>
    <p>
      There's no standard, or enforcement of any standard or quality level,
      etc., which leads us to a new problem.
    </p>
  </td></tr>
  <tr><td><a href="#47"><img id="47" class="slide" src="/assets/images/cheeseshop/47.png"></a></td><td>
    <p>
      At this time, every project came with it's own special little way to
      build it. Maybe it was a Python script, maybe it was a Makefile, maybe
      it was just instructions in a text file.
    <p>
    </p>
      This is really painful for users!
    </p>
  </td></tr>
  <tr><td><a href="#48"><img id="48" class="slide" src="/assets/images/cheeseshop/48.png"></a></td><td>
    <p>
      So, at the "1998 international Python Conference" (which would later
      become PyCon), a little project got started called "distutils", for
      "distribution utilities".
    </p>
    <p>
      This was included in the standard library in Python 1.6, circa 2000.
    </p>
  </td></tr>
  <tr><td><a href="#49"><img id="49" class="slide" src="/assets/images/cheeseshop/49.png"></a></td><td>
    <p>
      This gave us the somewhat familiar incantation, "python setup.py
      whatever".
    </p>
    <p>
      I think some people have run this without really thinking about what's
      going on here: it's just a Python script! With a little magic thanks to
      the standard library.
    </p>
    <p>
      The idea was: why write a domain specific language or add a new config
      file when you already have the full power of Python at your disposal?
      Let's just write more Python!
    </p>
    <p>
      (We'll see why in a bit...)
    </p>
  </td></tr>
  <tr><td><a href="#50"><img id="50" class="slide" src="/assets/images/cheeseshop/50.png"></a></td><td>
    <p>
      And this was really just a build tool, to replace those Makefiles.  The
      goal was to <i>make</i> something in a consistent way, that could then be
      installed.
    </p>
  </td></tr>
  <tr><td><a href="#51"><img id="51" class="slide" src="/assets/images/cheeseshop/51.png"></a></td><td>
    <p>
      The <code>distutils</code> library also gave us a standard way to package
      up source code for sharing, by turning it into a compressed archive like
      a zip or a tar.gz.
    </p>
  </td></tr>
  <tr><td><a href="#52"><img id="52" class="slide" src="/assets/images/cheeseshop/52.png"></a></td><td>
    <p>
      This is also known as an "sdist".
    </p>
  </td></tr>
  <tr><td><a href="#53"><img id="53" class="slide" src="/assets/images/cheeseshop/53.png"></a></td><td>
    <p>
      I like to say this like a snake.
    </p>
  </td></tr>
  <tr><td><a href="#54"><img id="54" class="slide" src="/assets/images/cheeseshop/54.png"></a></td><td>
    <p>
      This command might be a little more familiar.
    </p>
  </td></tr>
  <tr><td><a href="#55"><img id="55" class="slide" src="/assets/images/cheeseshop/55.png"></a></td><td>
    <p>
      But pretty quickly it became obvious that sometimes, source distributions
      weren't going to cut it.
    </p>
    <p>
      Sometimes, source distributions are fine. But sometimes they have so much
      to do during the build step, possibly even compiling some C code, that it
      becomes costly to do this every time you want to install some dependency,
      and it feels wasteful if you're doing it over and over again for the same
      architecture.
    </p>
  </td></tr>
  <tr><td><a href="#56"><img id="56" class="slide" src="/assets/images/cheeseshop/56.png"></a></td><td>
    <p>
      The solution is built distributions. Instead, you take a distribution
      that's been pre-built for your architecture, and you just drop it in
      place, no build step necessary.
    </p>
  </td></tr>
  <tr><td><a href="#57"><img id="57" class="slide" src="/assets/images/cheeseshop/57.png"></a></td><td>
    <p>
      This is also known as a "bdist", for "built distribution".
    </p>
  </td></tr>
  <tr><td><a href="#58"><img id="58" class="slide" src="/assets/images/cheeseshop/58.png"></a></td><td>
    <p>
      And you could create it like this.
    </p>
  </td></tr>
  <tr><td><a href="#59"><img id="59" class="slide" src="/assets/images/cheeseshop/59.png"></a></td><td>
    <p>
      The <code>distutils</code> library was pretty great: having a consistent
      way to just build things was immensely helpful. But it punted on solving
      two key problems.
    </p>
    <p>
      The first of which is the generic idea of "packaging". By this I mean:
      how do I get the user to the state right before they run the build
      command? Where they have everything they need, but it's just not put
      together yet?
    </p>
  </td></tr>
  <tr><td><a href="#60"><img id="60" class="slide" src="/assets/images/cheeseshop/60.png"></a></td><td>
    <p>
      The original <code>distutils</code> authors saw this as a solved problem.
    </p>
    <p>
      All the platforms they wanted to run Python on already had system-level
      package managers. I'm talking about Linux package mangers like RPM.
    </p>
    <p>
      They couldn't imagine developers would ever want to do development on
      platforms that didn't have a package manager.
    </p>
    <p>
      Well, guess what.
    </p>
  </td></tr>
  <tr><td><a href="#61"><img id="61" class="slide" src="/assets/images/cheeseshop/61.png"></a></td><td>
    <p>
      As it turns out, developers <i>love</i> developing on platforms that
      don't have official package managers, like macOS and Windows.
    </p>
  </td></tr>
  <tr><td><a href="#62"><img id="62" class="slide" src="/assets/images/cheeseshop/62.png"></a></td><td>
    <p>
      There's another problem with this solution.
    </p>
  </td></tr>
  <tr><td><a href="#63"><img id="63" class="slide" src="/assets/images/cheeseshop/63.png"></a></td><td>
    <p>
      Maybe your platform does have a package manager, but packages in platform
      distributions usually lag behind releases, because once the author has
      published the code some way, the platform maintainers need to take that
      and package it up for the specific platform and put into the platform's
      specific index.
    </p>
    <p>
      And as a user, you want that fresh release <i>now</i>.
    </p>
  </td></tr>
  <tr><td><a href="#64"><img id="64" class="slide" src="/assets/images/cheeseshop/64.png"></a></td><td>
    <p>
      The solution was to create package index just for Python, for authors to
      publish directly to, and users to get software directly from.
    </p>
    <p>
      We call this, the Python Package Index.
    </p>
  </td></tr>
  <tr><td><a href="#65"><img id="65" class="slide" src="/assets/images/cheeseshop/65.png"></a></td><td>
    <p>
      Here it is in October 2002. It gave us an official, consistent, and
      centralized place to "put" Python software.
    </p>
    <p>
      I say "put" because it still links to externally hosted files, but it's
      got a bit more structure.
    </p>
  </td></tr>
  <tr><td><a href="#66"><img id="66" class="slide" src="/assets/images/cheeseshop/66.png"></a></td><td>
    <p>
      This is also known as PyPI.
    </p>
  </td></tr>
  <tr><td><a href="#69"><img id="69" class="slide" src="/assets/images/cheeseshop/69.png"></a></td><td>
    <p>
      Say it with me: Pie Pea Eye.
    </p>
    <p>
      Not "pie pie", that's something else. Again, naming things is hard.
    </p>
  </td></tr>
  <tr><td><a href="#70"><img id="70" class="slide" src="/assets/images/cheeseshop/70.png"></a></td><td>
    <p>
      PyPI is sometimes called the Cheeseshop.
    </p>
  </td></tr>
  <tr><td><a href="#71"><img id="71" class="slide" src="/assets/images/cheeseshop/71.png"></a></td><td>
    <p>
      This is a reference to this Monty Python skit, where a man goes into a
      cheeseshop which has no cheese for sale.
    </p>
    <p>
      The joke is that when PyPI was first created, there was nothing in it. Hence, the cheeseshop.
    </p>
    <p>
      But it does have stuff in it now, so it's not really even appropriate to
      call it that anymore.
    </p>
  </td></tr>
  <tr><td><a href="#72"><img id="72" class="slide" src="/assets/images/cheeseshop/72.png"></a></td><td>
    <p>
      The other thing that <code>distutils</code> punted on was being able to specify
      dependencies. There was no way to say that package A requires that
      package B gets installed as well.
    </p>
    <p>
      This makes sense: why bother specifying dependencies when you don't know
      where to get the dependency from?
    </p>
    <p>
      Now that we have a package index, it's possible to not only point to some
      version of a package somewhere, but it's also possible to distribute
      something that does more than <code>distutils</code>. Which again, was in the standard
      library and came with your Python.
    </p>
  </td></tr>
  <tr><td><a href="#73"><img id="73" class="slide" src="/assets/images/cheeseshop/73.png"></a></td><td>
    <p>
      The <code>setuptools</code> package essentially monkey-patched
      <code>distutils</code> in the standard library.
    </p>
    <p>
      There are some advantages here: because <code>setuptools</code> is on
      PyPI, it's quicker to ship new code to users, because users don't have to
      upgrade their entire Python distribution to get a new
      <code>setuptools</code>.
    </p>
    <p>
      There are some disadvantages, though: monkeypatching is never really a
      good idea, especially monkeypatching the standard library.
    </p>
    <p>
      But once we had <code>setuptools</code>, all sorts of other things came along with it.
    </p>
  </td></tr>
  <tr><td><a href="#74"><img id="74" class="slide" src="/assets/images/cheeseshop/74.png"></a></td><td>
    <p>
      For example, now that we can specify dependencies easily, we make
      them easier to install as well.
    </p>
  </td></tr>
  <tr><td><a href="#75"><img id="75" class="slide" src="/assets/images/cheeseshop/75.png"></a></td><td>
    <p>
      And thus we got <code>easy_install</code>, which came along with
      <code>setuptools</code>, and allowed users to install dependencies for a
      project directly from PyPI.
    </p>
    <p>
      And this did, in theory, make it easier for users to install various
      projects.
    </p>
  </td></tr>
  <tr><td><a href="#76"><img id="76" class="slide" src="/assets/images/cheeseshop/76.png"></a></td><td>
    <p>
      It also introduced a new type of built distribution, the "egg"
      distribution, because the existing ones weren't cutting it.
    </p>
    <p>
      There were other types of eggs too, but the built distribution type of
      egg is the important one.
    </p>
    <p>
      An egg was simply a zip file, with some metadata, could contain Python
      byte code as well.
    </p>
  </td></tr>
  <tr><td><a href="#77"><img id="77" class="slide" src="/assets/images/cheeseshop/77.png"></a></td><td>
    <p>
      The name "egg" comes from Python. Pythons lay eggs.
    </p>
  </td></tr>
  <tr><td><a href="#78"><img id="78" class="slide" src="/assets/images/cheeseshop/78.png"></a></td><td>
    <p>
      But <code>easy_install</code> gave us some new problems.
    </p>
  </td></tr>
  <tr><td><a href="#79"><img id="79" class="slide" src="/assets/images/cheeseshop/79.png"></a></td><td>
    <p>
      It was really good at installing. So easy!
    </p>
    <p>
      It couldn't uninstall...
    </p>
    <p>
      It couldn't tell you what you had installed...
    </p>
    <p>
      And it mucked around with <code>sys.path</code>, which is generally not
      great.
    </p>
  </td></tr>
  <tr><td><a href="#80"><img id="80" class="slide" src="/assets/images/cheeseshop/80.png"></a></td><td>
    <p>
      So the solution was a new tool called <code>pyinstall</code>, circa 2008.
    </p>
    <p>
      You might have never heard of <code>pyinstall</code>. This is because
      pretty much as soon as <code>pyinstall</code> was created, we had a new
      problem.
    </p>
    <p>
      The name <code>pyinstall</code> is too long, and typing <code>pyinstall
      install</code> feels redundant.
    </p>
    <p>
      Again, naming things is hard!
    </p>
  </td></tr>
  <tr><td><a href="#81"><img id="81" class="slide" src="/assets/images/cheeseshop/81.png"></a></td><td>
    <p>
      Thus <code>pyinstall</code> becomes <code>pip</code> almost immediately.
      The name <code>pip</code> isn't an obscure reference, it stands for "pip
      installs packages".
    </p>
    <p>
      We swapped redundancy for a recursive backronym.
    </p>
    <p>
      So while <code>easy_install</code> is still around, <code>pip</code> soon
      becomes the preferred installer.
    </p>
  </td></tr>
  <tr><td><a href="#82"><img id="82" class="slide" src="/assets/images/cheeseshop/82.png"></a></td><td>
    <p>
      Because of all the problems with <code>easy_install</code>,
      <code>pip</code> did a kind of funny thing and just ignored eggs
      entirely, and only installed from source distributions.
    </p>
  </td></tr>
  <tr><td><a href="#83"><img id="83" class="slide" src="/assets/images/cheeseshop/83.png"></a></td><td>
    <p>
      At this point, people are starting to use <code>pip</code> to install dependencies for
      applications, not dependencies for other packages.
    </p>
    <p>
      Essentially, for an application there is no top-level package to install,
      so if we want a way to specify dependencies for an application, what do
      we do?
    </p>
  </td></tr>
  <tr><td><a href="#84"><img id="84" class="slide" src="/assets/images/cheeseshop/84.png"></a></td><td>
    <p>
      The solution is that <code>pip</code> introduces a file,
      <code>requirements.txt</code>, which includes the ability to pin specific
      versions of dependencies.
    </p>
  </td></tr>
  <tr><td><a href="#85"><img id="85" class="slide" src="/assets/images/cheeseshop/85.png"></a></td><td>
    <p>
      This gives us a familiar command, and allows for semi-reproducible
      environments.
    </p>
  </td></tr>
  <tr><td><a href="#86"><img id="86" class="slide" src="/assets/images/cheeseshop/86.png"></a></td><td>
    <p>
      So now everyone's happily <code>pip install</code>-ing, but we have a new
      problem.
    </p>
    <p>
      Installing from PyPI is getting pretty slow. Remember, it's still just an
      index.
    </p>
    <p>
      So when <code>pip</code> has to install something, it has to crawl PyPI,
      then a bunch of other domains, and these domains might not be performant
      (and for that matter, PyPI might not be either).
    </p>
  </td></tr>
  <tr><td><a href="#87"><img id="87" class="slide" src="/assets/images/cheeseshop/87.png"></a></td><td>
    <p>
      Another problem this introduces is that as a package maintainer, my users
      have to trust 3rd party domains.
    </p>
    <p>
      What happens when I forget to re-register the domain my package is hosted
      on? An attacker can go and register it, put malicious code in place.
    </p>
    <p>
      My users will have no idea, they are so used to <code>pip</code> trying
      to connect to random domains willy-nilly that they'll never notice.
    </p>
  </td></tr>
  <tr><td><a href="#88"><img id="88" class="slide" src="/assets/images/cheeseshop/88.png"></a></td><td>
    <p>
      The solution to this is that PyPI needs to transition to literally
      hosting the distributions.
    </p>
  </td></tr>
  <tr><td><a href="#89"><img id="89" class="slide" src="/assets/images/cheeseshop/89.png"></a></td><td>
    <p>
      This is standardized in PEP 438.
    </p>
  </td></tr>
  <tr><td><a href="#90"><img id="90" class="slide" src="/assets/images/cheeseshop/90.png"></a></td><td>
    <p>
      Around this time we start to notice a new problem.
    </p>
    <p>
      As it turns out, all the problems we needed built distributions to solve
      are still problems! But we don't want eggs, eggs are bad.
    </p>
  </td></tr>
  <tr><td><a href="#91"><img id="91" class="slide" src="/assets/images/cheeseshop/91.png"></a></td><td>
    <p>
      The solution to this problem is the wheel distribution. This is another
      built distribution, and very similar to eggs, it's also just a zipfile.
    </p>
    <p>
      This format has learned from the mistakes of <code>easy_install</code>
      and the egg distribution.
    </p>
  </td></tr>
  <tr><td><a href="#92"><img id="92" class="slide" src="/assets/images/cheeseshop/92.png"></a></td><td>
    <p>
      And, most importantly, it has a specification, PEP 427.
    </p>
    <p>
      There's also a convenient feature where you can look at a wheel file and
      tell what platform it's for just by the filename.
    </p>
  </td></tr>
  <tr><td><a href="#93"><img id="93" class="slide" src="/assets/images/cheeseshop/93.png"></a></td><td>
    <p>
      The name "wheel" came from a "wheel of cheese": you put wheels in a cheeseshop.
    </p>
    <p>
      I like to think the authors of the spec really got this name right,
      because in addition, nobody can say they're going to "reinvent the
      wheel".
    </p>
  </td></tr>
  <tr><td><a href="#94"><img id="94" class="slide" src="/assets/images/cheeseshop/94.png"></a></td><td>
    <p>
      At this point a lot of people are depending on PyPI, and we start to
      become a little more focused on making sure it's secure
    </p>
    <p>
      And as it turns out, <code>distutils</code>'s upload command is sending user
      credentials in plaintext.
    </p>
    <p>
      This means your PyPI credentials could be intercepted, or that you might
      not even be talking to PyPI at all.
    </p>
  </td></tr>
  <tr><td><a href="#95"><img id="95" class="slide" src="/assets/images/cheeseshop/95.png"></a></td><td>
    <p>
      The solution to this problem is twine. In the same vein as <code>setuptools</code> and
      <code>pip</code>, this is a separate package from the standard library, available from
      PyPI, which is responsible for securely uploading a new project to PyPI.
    </p>
  </td></tr>
  <tr><td><a href="#96"><img id="96" class="slide" src="/assets/images/cheeseshop/96.png"></a></td><td>
    <p>
      The name comes from tying up packages with twine before sending them
    </p>
    <p>
      This name doesn't really correlate well with what it does though. Twine
      doesn't do anything _to_ your package, all the bundling has already been
      done
    </p>
    <p>
      It just looks up some information about your package, and it knows how to
      send it, securely, to PyPI. It's more like a package carrier but...
      naming things is hard!
    </p>
  </td></tr>
  <tr><td><a href="#97"><img id="97" class="slide" src="/assets/images/cheeseshop/97.png"></a></td><td>
    <p>
      At this point we have a new problem: PyPI is starting to show it's age.
    </p>
  </td></tr>
  <tr><td><a href="#98"><img id="98" class="slide" src="/assets/images/cheeseshop/98.png"></a></td><td>
    <p>
      Here's PyPI in 2007, about four years old.
    </p>
  </td></tr>
  <tr><td><a href="#99"><img id="99" class="slide" src="/assets/images/cheeseshop/99.png"></a></td><td>
    <p>
      Here's PyPI in April of 2018, over ten years later.
    </p>
  </td></tr>
  <tr><td><a href="#100"><img id="100" class="slide" src="/assets/images/cheeseshop/100.png"></a></td><td>
    <p>
      Here they are side by side. It's kind of like one of those "spot the difference" games.
    </p>
  </td></tr>
  <tr><td><a href="#101"><img id="101" class="slide" src="/assets/images/cheeseshop/101.png"></a></td><td>
    <p>
      It's not really fair to just visually compare PyPI in 2007 with PyPI in 2018.
    </p>
    <p>
      One big difference that might be hard to see is the number of packages
      went from less than 3K to more than 130K.  In that time PyPI went from
      "a" place to get Python packages to "the" place to get Python packages.
      This growth included lots of issues with PyPI being down or having
      outages.  And there were a <i>lot</i> of things that had to happen behind
      the scenes so that PyPI could continue to work.
    </p>
    <p>
      The other thing is that, by it's very nature, PyPI predates almost all of
      the packages that exist on it, including all of the web frameworks and
      testing frameworks you're familiar with.
    </p>
    <p>
      So it's fifteen years old, has pretty much no tests, doesn't use a modern
      web framework. To run it locally to do development, you actually have to
      go comment out large parts of it just to get it to run.  </p>
    <p>
      What should we do?
    </p>
  </td></tr>
  <tr><td><a href="#102"><img id="102" class="slide" src="/assets/images/cheeseshop/102.png"></a></td><td>
    <p>
      Well, we could rewrite it all from scratch.
    </p>
    <p>
      Normally if you ask me if a full-stack rewrite, of a core piece of
      infrastructure, depended on by hundreds of thousands of users would ever
      succeed, I'd tell you no.
    </p>
  </td></tr>
  <tr><td><a href="#103"><img id="103" class="slide" src="/assets/images/cheeseshop/103.png"></a></td><td>
    <p>
      But it did. This is our new PyPI, and it's a complete rewrite.
    </p>
  </td></tr>
  <tr><td><a href="#104"><img id="104" class="slide" src="/assets/images/cheeseshop/104.png"></a></td><td>
    <p>
      It's also called Warehouse, as in a place to put packages (or cheese wheels).
    </p>
    <p>
      This is a project that started more or less in 2011, and had a number of
      goals, including HTTPS everywhere, using current best practices, a modern
      web framework, and tests! So many tests.
    </p>
  </td></tr>
  <tr><td><a href="#105"><img id="105" class="slide" src="/assets/images/cheeseshop/105.png"></a></td><td>
    <p>
      It officially became PyPI in in April of 2018.
    </p>
    <p>
      This was a tremendous undertaking which absolutely would not have been
      possible to have been completed in a reasonable amount of time without
      significant financial support from Mozilla.
    </p>
  </td></tr>
  <tr><td><a href="#106"><img id="106" class="slide" src="/assets/images/cheeseshop/106.png"></a></td><td>
    <p>
      So that's it, right? We've solved all the problems, we launched PyPI.
    </p>
    <p>
      Good job everyone!
    </p>
  </td></tr>
  <tr><td><a href="#107"><img id="107" class="slide" src="/assets/images/cheeseshop/107.png"></a></td><td>
    <p>
      No, we still have problems. But this is the nature of software!
    </p>
    <p>
      Once we build the new shiny thing, we start to realize what else it can
      do, or what the need actually is.
    </p>
  </td></tr>
  <tr><td><a href="#108"><img id="108" class="slide" src="/assets/images/cheeseshop/108.png"></a></td><td>
    <p>
      One problem is that packaging is still kinda hard, especially if you're
      new to it all. There are a lot of different tools and things you've never
      heard of until maybe today.
    </p>
  </td></tr>
  <tr><td><a href="#109"><img id="109" class="slide" src="/assets/images/cheeseshop/109.png"></a></td><td>
    <p>
      One solution to this problem is the Python Packaging Guide, at <a
      href="https://packaging.python.org">packaging.python.org</a>.
    </p>
    <p>
      This is a really carefully crafted and well-maintained guide to Python
      packaging.
    </p>
  </td></tr>
  <tr><td><a href="#110"><img id="110" class="slide" src="/assets/images/cheeseshop/110.png"></a></td><td>
    <p>
      Another solution to this problem is the <code>sampleproject</code>, which
      is a skeleton project for your Python package.
    </p>
    <p>
      This represents the current best practices for creating a new Python
      package.
    </p>
  </td></tr>
  <tr><td><a href="#111"><img id="111" class="slide" src="/assets/images/cheeseshop/111.png"></a></td><td>
    <p>
      Another solution is just general care and maintenance. In general, I
      think these more modern projects are more well-specified, and easier to
      maintain.
    </p>
    <p>
      In addition, there is a serious focus on making these projects accessible
      to newcomers.
    </p>
  </td></tr>
  <tr><td><a href="#112"><img id="112" class="slide" src="/assets/images/cheeseshop/112.png"></a></td><td>
    <p>
      In fact, I would say that we have a new "problem" now. Python Packaging
      is perhaps a little too easy.
    </p>
  </td></tr>
  <tr><td><a href="#113"><img id="113" class="slide" src="/assets/images/cheeseshop/113.png"></a></td><td>
    <p>
      I could have called this talk "Python Packaging: So Easy a Spammer Could
      Do It".
    </p>
    <p>
      Having packaging be hard actually has some unintentional benefits.
      Namely, that folks that aren't truly invested in it can't figure out how
      to use it.
    </p>
    <p>
      Unfortunately this excludes a lot of people that don't have malicious
      intent though. So while lowering that barrier is a priority, it does
      produce new problems like spam packages on PyPI.
    </p>
  </td></tr>
  <tr><td><a href="#114"><img id="114" class="slide" src="/assets/images/cheeseshop/114.png"></a></td><td>
    <p>
      There's another problem that's common these days: Maybe you need more
      than Python and Python libraries. Maybe you need R, LLVM, HDF5, MKL...
      maybe, you don't even have Python on your system yet.
    </p>
    <p>
      These problems are kind of outside the scope of the "Python Packaging",
      which assume that a) you have Python b) you really just want to do Python
      (and of course, sometimes some C).
    </p>
  </td></tr>
  <tr><td><a href="#115"><img id="115" class="slide" src="/assets/images/cheeseshop/115.png"></a></td><td>
    <p>
      But this is definitely within the scope of <code>conda</code>, which is
      provided by Anaconda. It's a Python-agnostic packaging tool and
      installer, which satisfies a lot of those use cases.
    </p>
  </td></tr>
  <tr><td><a href="#116"><img id="116" class="slide" src="/assets/images/cheeseshop/116.png"></a></td><td>
    <p>
      Another problem we currently have is having an ergonomic way to specify reproducible environments.
    </p>
    <p>
      The <code>requirements.txt</code> file was a great step towards this: we
      can use it to specify exact versions and hashes of any dependency for
      <code>pip</code> to install.
    </p>
    <p>
      However, creating and maintaining this file can be challenging, and often
      we have multiple requirements files, for deployment, for development, for
      testing, for linting, etc.
    </p>
  </td></tr>
  <tr><td><a href="#117"><img id="117" class="slide" src="/assets/images/cheeseshop/117.png"></a></td><td>
    <p>
      The solution is the Pipfile specification. It's a single human-editable
      file (<code>Pipfile</code>) and a single generated file
      (<code>Pipfile.lock</code>) with fully deterministic dependencies.
    </p>
    <p>
      This file can be shared across multiple dependency-installing tools. If
      you come from another ecosystem, this might feel familiar to
      <code>Gemfile.loc</code>, <code>yarn.lock</code>, etc.
    </p>
  </td></tr>
  <tr><td><a href="#118"><img id="118" class="slide" src="/assets/images/cheeseshop/118.png"></a></td><td>
    <p>
      Another problem is the ability to put arbitrary code in
      <code>setup.py</code>, because it's just a Python script. This is
      sometimes a good thing, as it allows people to use anything necessary to
      get their package built.
    </p>
    <p>
      However, it has problems as well. There's no way to truly predict what
      dependencies a package will have without executing the
      <code>setup.py</code> file, and even then, it's not guaranteed to be
      deterministic. This makes it really hard to reason about source
      distributions.
    </p>
  </td></tr>
  <tr><td><a href="#119"><img id="119" class="slide" src="/assets/images/cheeseshop/119.png"></a></td><td>
    <p>
      The other problem I'll call the
      "<code>distutils</code>/<code>setuptools</code>" dance. Extending and
      maintaining these projects is difficult: <code>distutils</code> because
      it's in the standard library, and <code>setuptools</code> because it's a
      big old ball of mud on top of <code>distutils</code>.
    </p>
    <p>
      So while there do exist various solutions to the above problems, they're
      hard to implement and even harder to maintain.
    </p>
    <p>
      Also, it's very difficult to use anything else, as these are essentially
      the de-facto standard interface. Changing them becomes a bit of a chicken
      and egg problem.
    </p>
  </td></tr>
  <tr><td><a href="#120"><img id="120" class="slide" src="/assets/images/cheeseshop/120.png"></a></td><td>
    <p>
      The solution to this problem is PEP 517 and PEP 518.
    </p>
  </td></tr>
  <tr><td><a href="#121"><img id="121" class="slide" src="/assets/images/cheeseshop/121.png"></a></td><td>
    <p>
      PEP 517 provides a minimal interface for installers like <code>pip</code>
      to interact with source trees and source distributions, allowing a
      package to specify a non-<code>distutils</code> backend to be used for
      installation.
    </p>
  </td></tr>
  <tr><td><a href="#122"><img id="122" class="slide" src="/assets/images/cheeseshop/122.png"></a></td><td>
    <p>
      PEP 518 provides a way to specify the build system requirements for
      Python projects. These are dependencies you'd need to <i>install</i> a
      given package, not to run it.
    </p>
  </td></tr>
  <tr><td><a href="#123"><img id="123" class="slide" src="/assets/images/cheeseshop/123.png"></a></td><td>
    <p>
      Both these specifications use a new file, <code>pyproject.toml</code>,
      and together they provide a way to step away from <code>setuptools</code> and
      <code>distutils</code> entirely, and allow users to specify their own build
      requirements for a project, which can then be installed prior to
      building.
    </p>
  </td></tr>
  <tr><td><a href="#124"><img id="124" class="slide" src="/assets/images/cheeseshop/124.png"></a></td><td>
    <p>
      That sounds like a lot of problems, you might say.
    </p>
    <p>
      Also consider that unlike Anaconda, unlike NPM, and with only a few small
      exceptions, Python Packaging is entirely volunteer-driven.
    </p>
    <p>
      So maybe you'd like to help.
    </p>
  </td></tr>
  <tr><td><a href="#125"><img id="125" class="slide" src="/assets/images/cheeseshop/125.png"></a></td><td>
    <p>
      Most of the PyPA projects like PyPI and <code>pip</code> have a "good
      first issue" label in their issue trackers. So if you want to become a
      contributor today, you can.
    </p>
  </td></tr>
  <tr><td><a href="#127"><img id="127" class="slide" src="/assets/images/cheeseshop/127.png"></a></td><td>
    <p>
      We also development sprints at various Python conferences and other
      events. If you're a contributor, come find me at one of these, and I'll
      be happy to give you one of these contributor stickers.
    </p>
  </td></tr>
  <tr><td><a href="#128"><img id="128" class="slide" src="/assets/images/cheeseshop/128.png"></a></td><td>
    <p>
      I've told you how to help us, here's how we can help you.
    </p>
  </td></tr>
  <tr><td><a href="#129"><img id="129" class="slide" src="/assets/images/cheeseshop/129.png"></a></td><td>
    <p>
      If you're having problems, you can do the following, in order of how
      quickly you need your problem solved, from "very quick" to "might take a
      while":
    </p>
    <ul>
      <li>
        You can tweet at <a href="https://twitter.com/pypi">@PyPI</a> or <a
        href="https://twitter.com/thepypa">@ThePyPA</a>
      </li>
      <li>
        You can visit <a
        href="https://packaging.python.org">packaging.python.org</a> for
        guides on how to do specific things.
      </li>
      <li>
        You can file an issue on the tracker for a given tool
      </li>
      <li>
        You can chat on IRC: `#pypa` Freenode channel
      </li>
      <li>
        You can file an issue on the <a
        href="https://github.com/pypa/packaging-problems">Packaging
        Problems</a> tracker, for long term, ecosystem-wide changes.
      </li>
    </ul>
  </td></tr>
  <tr><td><a href="#130"><img id="130" class="slide" src="/assets/images/cheeseshop/130.png"></a></td><td>
    <p>
      To summarize: packaging isn't bad! But there are always going to be
      problems to be solved. We've made gradual changes over a long period of
      time, and each change is a response to an evolving need.
    </p>
    <p>
      Comparatively, it used to be really bad, and we might have for forgotten,
      or just never known, how hard it used to be.
    </p>
    <p>
      So the next time you are frustrated with Python Packaging, imagine a world
      with no <code>pip</code>, no PyPI..
    </p>
    <p>
      And consider making a pull request.
    </p>
  </td></tr>
  <tr><td><a href="#131"><img id="131" class="slide" src="/assets/images/cheeseshop/131.png"></a></td><td>
    <p>
      Thanks!
    </p>
    <ul>
      <li>
        Github: <a href="https://github.com/di"><code>@di</code></a>
      </li>
      <li>
        Twitter: <a href="https://twitter.com/di_codes"><code>@di_codes</code></a>
      </li>
    </ul>
  </td></tr>
</table>
</div>
